# Reading Assignment 1

##1.1

All software engineering projects must handle requirements gathering, high level design, low level design, development, testing, deployment, and maintenance.

##1.2

Requirements gathering is determining the features that will be included in the software project once it's delivered. High level design is determining the components of the project. Low level design is determining how each component of the project is constructed. Development is actually coding and building the system. Testing is ensuring the system works as intended and meets requirements. Deployment is delivering the final product to the customer. Maintenance is fixing bugs and troubleshooting issues found by the users.

##2.5

JBEG stands for "Just Barely Good Enough" and is a school of software development thought that emphasizes the creation of just enough documentation and comments to code to be useful. It is meant to deter people from wasting time making too much documentation that requires significant time and effort to maintain alongside the code.

##3.2

The critical path is the path START =>H => I => D => E => M => Q. Based on the critical path, the project should take 32 days to complete.

##3.4

##3.6

Unpredictable problems, such as sick leave, can be handled by accounting for them in the estimated time for projects to be completed. For example, if a project is initially estimated to be finished in 15 days, a readjustment to the estimate taking into consideration unforeseeable issues could extend the estimate to approximately 20 days. Another way to handle unpredictable problems is to periodically check the progress of the project to ensure it is on schedule or to readjust the estimated time of completion.

##3.8

The two biggest mistakes possible to make when tracking progress are ignoring arising problems and adding extra developers to a task. Ignoring issues with falling behind schedule in the hopes of making up the time later will cause the project to fall further and further behind schedule. On the other hand, adding developers to a behind schedule task will slow progress due to the need to get the new developers up to speed with the project.

##4.1

Good requirements are clear, unambiguous, consistent, prioritized, and verifiable. The requirements should be easy to understand and precisely stated in order to be clear and unambiguous. The requirements should also remain the same throughout the length of the project and come in order of priority. Lastly, it should be possible to verify that the constructed software system meets the specified requirements.

##4.3

Business Requirements: None
User Requirements: A, B, C, D, E, L, N
Functional Requirements: A, B, C, D, E, F, I, J, K, L, M, N, O, P
Nonfunctional Requirements: G, H
Implementation Requirements: None

There are no requiremnets under the business nor implementation category because no requirement specifies business initiatives nor implementation issues.

##4.9

Must: Indicate what the word was at the end of the game
Should: Have frontend in line with modern design principles, Work in portrait and landscape phone orientation
Could: Keep track of wins and losses
Wont: